// ============================================================
//  Goal: for universe size = 4, find the Not Dilation and A2D
//  model that is minimal extension of the monotone relation
//  after transitivity reduction.
//
//  The tentative design is that we transform the above minimal
//  extension into axiomatic contraints over z3 solvers.
// ============================================================


#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <map>
#include <algorithm>
#include <thread>
#include <mutex>
#include <atomic>
#include <queue>
#include <condition_variable>
#include <chrono>
#include "z3++.h"

// ============================================================
//  Bitmask Utilities
// ============================================================
//  Goal: represent set operations using bit operations whereby 
//  Omega = {0,..,n-1} and subset S ⊆ Omega is represented as 
//  an integer bitmask.
// ============================================================

namespace BitOps {
    // Check if element k is in the bitmask
    inline bool contains(int mask, int k) {
        return (mask & (1 << k)) != 0;
    }
    
    // Set union (bitwise OR)
    inline int set_union(int mask1, int mask2) {
        return mask1 | mask2;
    }
    
    // Set intersection (bitwise AND)
    inline int set_intersection(int mask1, int mask2) {
        return mask1 & mask2;
    }
    
    // Set complement with respect to universe of size n
    inline int set_complement(int mask, int n) {
        return ((1 << n) - 1) ^ mask;
    }
    
    // Check if mask1 ⊆ mask2
    inline bool is_subset(int mask1, int mask2) {
        return (mask1 & mask2) == mask1;
    }
    
    // Count elements in set (popcount)
    inline int cardinality(int mask) {
        int count = 0;
        while (mask) {
            count += mask & 1;
            mask >>= 1;
        }
        return count;
    }
    
    // Convert bitmask to string representation like "{0,2,3}"
    std::string to_string(int mask, int n) {
        std::ostringstream oss;
        oss << "{";
        bool first = true;
        for (int i = 0; i < n; ++i) {
            if (contains(mask, i)) {
                if (!first) oss << ",";
                oss << i;
                first = false;
            }
        }
        oss << "}";
        return oss.str();
    }

    // Verify that a partition is valid:
    // 1. Not empty
    // 2. Does not contain empty set
    // 3. Covers the universe Omega
    // 4. Elements are pairwise disjoint
    bool verify_partition(const std::vector<int>& partition, int universe_size) {
        int full_set = (1 << universe_size) - 1;

        // Check 1: Partition is not empty
        if (partition.empty()) {
            std::cerr << "Partition error: partition is empty\n";
            assert(false && "Partition is empty");
            return false;
        }

        // Check 2: No element is the empty set
        for (size_t i = 0; i < partition.size(); ++i) {
            if (partition[i] == 0) {
                std::cerr << "Partition error: element " << i << " is the empty set\n";
                assert(false && "Partition contains empty set");
                return false;
            }
        }

        // Check 3: Union of all elements equals the universe
        int union_all = 0;
        for (int cell : partition) {
            union_all = set_union(union_all, cell);
        }
        if (union_all != full_set) {
            std::cerr << "Partition error: does not cover universe. Union = " 
                      << to_string(union_all, universe_size) 
                      << ", expected " << to_string(full_set, universe_size) << "\n";
            assert(false && "Partition does not cover universe");
            return false;
        }

        // Check 4: Elements are pairwise disjoint
        for (size_t i = 0; i < partition.size(); ++i) {
            for (size_t j = i + 1; j < partition.size(); ++j) {
                if (set_intersection(partition[i], partition[j]) != 0) {
                    std::cerr << "Partition error: elements " << i << " and " << j 
                              << " are not disjoint: "
                              << to_string(partition[i], universe_size) << " ∩ "
                              << to_string(partition[j], universe_size) << " = "
                              << to_string(set_intersection(partition[i], partition[j]), universe_size) << "\n";
                    assert(false && "Partition elements are not pairwise disjoint");
                    return false;
                }
            }
        }

        return true;
    }

    // Generate the field (Boolean algebra) generated by a partition
    // The field is the closure of the partition cells under union and complementation.
    // For a partition with k cells, the field has 2^k elements
    // Each element is a union of some subset of the partition cells
    std::vector<int> generate_field(const std::vector<int>& partition, int universe_size) {
        int k = static_cast<int>(partition.size());
        int field_size = 1 << k;  // 2^k elements in the field
        std::vector<int> field;
        field.reserve(field_size);
        
        // Each subset of {0, 1, ..., k-1} corresponds to a field element
        // which is the union of the corresponding partition cells
        for (int subset = 0; subset < field_size; ++subset) {
            int field_element = 0;
            for (int i = 0; i < k; ++i) {
                if (contains(subset, i)) {
                    field_element = set_union(field_element, partition[i]);
                }
            }
            field.push_back(field_element);
        }
        
        return field;
    }

    // Convert partition to string representation
    std::string partition_to_string(const std::vector<int>& partition, int n) {
        std::ostringstream oss;
        oss << "[";
        for (size_t i = 0; i < partition.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << to_string(partition[i], n);
        }
        oss << "]";
        return oss.str();
    }
}

// ============================================================
//  ModelAnalyzer - Analyze and describe models in natural language
// ============================================================
//  Decoupled from solver; operates on extracted boolean matrices
// ============================================================

namespace ModelAnalyzer {
    
    // Represents a pair (i, j) where i ≤ j in the relation
    struct RelationPair {
        int from;
        int to;
        
        bool operator==(const RelationPair& other) const {
            return from == other.from && to == other.to;
        }
        bool operator<(const RelationPair& other) const {
            if (from != other.from) return from < other.from;
            return to < other.to;
        }
    };
    
    // Extract all extension pairs: (i, j) where matrix[i][j] = true but i ⊄ j
    std::vector<RelationPair> extract_extensions(
        const std::vector<std::vector<bool>>& matrix,
        int universe_size
    ) {
        int ps = static_cast<int>(matrix.size());
        std::vector<RelationPair> extensions;
        
        for (int i = 0; i < ps; ++i) {
            for (int j = 0; j < ps; ++j) {
                if (matrix[i][j] && !BitOps::is_subset(i, j)) {
                    extensions.push_back({i, j});
                }
            }
        }
        
        return extensions;
    }
    
    // Compute transitive reduction of a set of pairs
    // Remove pair (a, c) if there exists b such that (a, b) and (b, c) are both in the set
    // AND the path a -> b -> c is valid in the full relation
    std::vector<RelationPair> transitive_reduction(
        const std::vector<RelationPair>& pairs,
        const std::vector<std::vector<bool>>& full_matrix
    ) {
        std::vector<RelationPair> reduced;
        
        for (const auto& pair : pairs) {
            bool is_redundant = false;
            
            // Check if this pair can be derived from other pairs via transitivity
            // (a, c) is redundant if exists b where full_matrix[a][b] && full_matrix[b][c]
            // and b != a and b != c
            int a = pair.from;
            int c = pair.to;
            
            for (int b = 0; b < static_cast<int>(full_matrix.size()); ++b) {
                if (b == a || b == c) continue;
                
                // Check if a ≤ b ≤ c in the full relation, making (a,c) derivable
                if (full_matrix[a][b] && full_matrix[b][c]) {
                    is_redundant = true;
                    break;
                }
            }
            
            if (!is_redundant) {
                reduced.push_back(pair);
            }
        }
        
        return reduced;
    }
    
    // Find equivalence classes: A ~ B iff A ≤ B and B ≤ A
    std::vector<std::vector<int>> find_equivalence_classes(
        const std::vector<std::vector<bool>>& matrix
    ) {
        int ps = static_cast<int>(matrix.size());
        std::vector<bool> visited(ps, false);
        std::vector<std::vector<int>> classes;
        
        for (int i = 0; i < ps; ++i) {
            if (visited[i]) continue;
            
            std::vector<int> eq_class;
            eq_class.push_back(i);
            visited[i] = true;
            
            for (int j = i + 1; j < ps; ++j) {
                if (!visited[j] && matrix[i][j] && matrix[j][i]) {
                    eq_class.push_back(j);
                    visited[j] = true;
                }
            }
            
            classes.push_back(eq_class);
        }
        
        return classes;
    }
    
    // Generate natural language description of the model
    void describe_model(
        const std::vector<std::vector<bool>>& matrix,
        int universe_size
    ) {
        int ps = static_cast<int>(matrix.size());
        
        std::cout << "\n=== NATURAL LANGUAGE DESCRIPTION ===\n\n";
        
        // 1. Find equivalence classes
        auto eq_classes = find_equivalence_classes(matrix);
        
        // Count non-trivial equivalence classes (size > 1)
        int non_trivial_count = 0;
        for (const auto& cls : eq_classes) {
            if (cls.size() > 1) non_trivial_count++;
        }
        
        std::cout << "1. EQUIVALENCE CLASSES (A ~ B means A ≤ B and B ≤ A):\n";
        if (non_trivial_count == 0) {
            std::cout << "   No non-trivial equivalences (antisymmetric relation).\n";
        } else {
            std::cout << "   Found " << non_trivial_count << " non-trivial equivalence class(es):\n";
            for (const auto& cls : eq_classes) {
                if (cls.size() > 1) {
                    std::cout << "   - {";
                    for (size_t i = 0; i < cls.size(); ++i) {
                        if (i > 0) std::cout << " ~ ";
                        std::cout << BitOps::to_string(cls[i], universe_size);
                    }
                    std::cout << "}\n";
                }
            }
        }
        
        // 2. Extract and reduce extensions
        auto extensions = extract_extensions(matrix, universe_size);
        auto minimal_extensions = transitive_reduction(extensions, matrix);
        
        std::cout << "\n2. MINIMAL GENERATING EXTENSIONS (beyond monotonicity):\n";
        std::cout << "   Total extensions: " << extensions.size() << "\n";
        std::cout << "   After transitive reduction: " << minimal_extensions.size() << "\n\n";
        
        if (minimal_extensions.empty()) {
            std::cout << "   The relation equals the minimal monotonic relation (subset ordering).\n";
        } else {
            std::cout << "   The relation is generated by monotonicity plus:\n";
            for (const auto& ext : minimal_extensions) {
                std::cout << "   - " << BitOps::to_string(ext.from, universe_size) 
                          << " ≤ " << BitOps::to_string(ext.to, universe_size) << "\n";
            }
        }
        
        // 3. Summary statistics
        std::cout << "\n3. SUMMARY:\n";
        std::cout << "   Universe size: " << universe_size << "\n";
        std::cout << "   Powerset size: " << ps << "\n";
        std::cout << "   Equivalence classes: " << eq_classes.size() 
                  << " (" << non_trivial_count << " non-trivial)\n";
        std::cout << "   Minimal generators: " << minimal_extensions.size() << " extension(s)\n";
        
        // 4. Plain English attempt
        std::cout << "\n4. PLAIN ENGLISH:\n";
        if (minimal_extensions.empty() && non_trivial_count == 0) {
            std::cout << "   \"The relation is exactly the subset ordering.\"\n";
        } else {
            std::cout << "   \"The relation extends subset ordering";
            if (non_trivial_count > 0) {
                std::cout << " by treating some non-subset pairs as equivalent";
            }
            if (!minimal_extensions.empty()) {
                std::cout << " with " << minimal_extensions.size() << " additional ordering(s)";
            }
            std::cout << ".\"\n";
        }
    }
}

// ============================================================
//  PartitionEnumerator - Generate all partitions of a set
// ============================================================
//  Uses recursive algorithm based on Stirling numbers
// ============================================================

namespace PartitionEnumerator {
    
    // Helper: recursively generate all partitions
    // elements[idx:] are elements yet to be assigned
    // current_partition holds the cells being built
    void generate_partitions_recursive(
        int n,
        int idx,
        std::vector<int>& current_partition,
        std::vector<std::vector<int>>& all_partitions
    ) {
        if (idx == n) {
            // All elements assigned - record this partition
            // Filter out empty cells
            std::vector<int> result;
            for (int cell : current_partition) {
                if (cell != 0) {
                    result.push_back(cell);
                }
            }
            if (!result.empty()) {
                all_partitions.push_back(result);
            }
            return;
        }
        
        int element_mask = 1 << idx;
        
        // Option 1: Add element to an existing cell
        for (size_t i = 0; i < current_partition.size(); ++i) {
            current_partition[i] |= element_mask;
            generate_partitions_recursive(n, idx + 1, current_partition, all_partitions);
            current_partition[i] ^= element_mask;  // Remove element
        }
        
        // Option 2: Create a new cell with this element
        current_partition.push_back(element_mask);
        generate_partitions_recursive(n, idx + 1, current_partition, all_partitions);
        current_partition.pop_back();
    }
    
    // Generate all partitions of {0, 1, ..., n-1}
    // Returns vector of partitions, where each partition is a vector of cell bitmasks
    std::vector<std::vector<int>> generate_all_partitions(int n) {
        std::vector<std::vector<int>> all_partitions;
        std::vector<int> current_partition;
        generate_partitions_recursive(n, 0, current_partition, all_partitions);
        return all_partitions;
    }
    
    // Generate all ordered pairs (I1, I2) where I1 != I2
    // For n=4: Bell(4) = 15 partitions → 15*14 = 210 pairs
    std::vector<std::pair<std::vector<int>, std::vector<int>>> 
    generate_partition_pairs(int n) {
        auto partitions = generate_all_partitions(n);
        std::vector<std::pair<std::vector<int>, std::vector<int>>> pairs;
        
        for (size_t i = 0; i < partitions.size(); ++i) {
            for (size_t j = 0; j < partitions.size(); ++j) {
                if (i != j) {
                    pairs.push_back({partitions[i], partitions[j]});
                }
            }
        }
        
        return pairs;
    }
}

// ============================================================
//  FrameVariables - Holds Z3 symbolic variables
// ============================================================
//  Decoupled from solver; can be shared across multiple solvers
// ============================================================

class FrameVariables {
    z3::context& ctx;
    int n;              // Universe size
    int powerset_size;  // 2^n subsets
    std::vector<std::vector<z3::expr>> R;  // R[i][j] = (subset_i ≤ subset_j)

public:
    FrameVariables(z3::context& c, int universe_size, bool silent = false)
        : ctx(c), n(universe_size), powerset_size(1 << universe_size) {
        
        // Create boolean matrix R[i][j]
        for (int i = 0; i < powerset_size; ++i) {
            R.emplace_back();
            for (int j = 0; j < powerset_size; ++j) {
                std::string var_name = "R_" + std::to_string(i) + "_" + std::to_string(j);
                R[i].push_back(ctx.bool_const(var_name.c_str()));
            }
        }
        if (!silent) {
            std::cout << "Created " << (powerset_size * powerset_size) << " boolean variables\n";
        }
    }

    // Accessors
    z3::context& context() { return ctx; }
    int universe_size() const { return n; }
    int size() const { return powerset_size; }
    z3::expr& get_R(int i, int j) { return R[i][j]; }
    const z3::expr& get_R(int i, int j) const { return R[i][j]; }
};

// ============================================================
//  AxiomEncoder - Methods to encode axioms into constraints
// ============================================================
//  Each axiom is a separate method; call directly as needed
//  Supports silent mode for parallel workers
// ============================================================

class AxiomEncoder {
    FrameVariables& vars;
    bool silent;

public:
    AxiomEncoder(FrameVariables& v, bool silent_mode = false) : vars(v), silent(silent_mode) {}

    // AXIOM: Transitivity - if i ≤ j and j ≤ k, then i ≤ k
    void encode_transitivity(z3::solver& s) {
        if (!silent) std::cout << "  Encoding transitivity...\n";
        for (int i = 0; i < vars.size(); ++i) {
            for (int j = 0; j < vars.size(); ++j) {
                for (int k = 0; k < vars.size(); ++k) {
                    // (R[i][j] ∧ R[j][k]) → R[i][k]
                    s.add(z3::implies(vars.get_R(i, j) && vars.get_R(j, k), vars.get_R(i, k)));
                }
            }
        }
    }

    // AXIOM: Monotonicity - subset inclusion implies ordering
    void encode_monotonicity(z3::solver& s) {
        if (!silent) std::cout << "  Encoding monotonicity...\n";
        for (int i = 0; i < vars.size(); ++i) {
            for (int j = 0; j < vars.size(); ++j) {
                if (BitOps::is_subset(i, j)) {
                    s.add(vars.get_R(i, j));  // i ⊆ j → i ≤ j
                }
            }
        }
    }

    // AXIOM: Non-triviality - it is not the case that the full set Omega and the empty set stand in the relation R.
    void encode_non_triviality(z3::solver& s) {
        if (!silent) std::cout << "  Encoding non-triviality...\n";
        int full_set = vars.size() - 1;  // Assuming full set is the last subset
        int empty_set = 0;                // Assuming empty set is the first subset
        s.add(!vars.get_R(full_set, empty_set));
    }

    // Axiom: Comparative Sure-thing Principle (CSTP) - for any disjoint subsets A, B and disjoint subsets C, D, if A ≤ C and B ≤ D, then A ∪ B ≤ C ∪ D.
    void encode_CSTP(z3::solver& s) {
        if (!silent) std::cout << "  Encoding Comparative Sure-thing Principle (CSTP)...\n";
        for (int A = 0; A < vars.size(); ++A) {
            for (int B = 0; B < vars.size(); ++B) {
                if (BitOps::set_intersection(A, B) != 0) continue; // A and B must be disjoint
                for (int C = 0; C < vars.size(); ++C) {
                    for (int D = 0; D < vars.size(); ++D) {
                        if (BitOps::set_intersection(C, D) != 0) continue; // C and D must be disjoint
                        int AB = BitOps::set_union(A, B);
                        int CD = BitOps::set_union(C, D);
                        // (R[A][C] ∧ R[B][D]) → R[AB][CD]
                        s.add(z3::implies(vars.get_R(A, C) && vars.get_R(B, D), vars.get_R(AB, CD)));
                    }
                }
            }
        }
    }

    // Axiom: Strict CSTP - for any subsets A, B, C, D, if A ∩ B = ∅ and C ∩ D = ∅, then (A < C and B < D) implies (A ∪ B) < (C ∪ D) where A < B means that A ≤ B and NOT B ≤ A.
    void encode_strict_CSTP(z3::solver& s) {
        if (!silent) std::cout << "  Encoding Strict Comparative Sure-thing Principle (Strict CSTP)...\n";
        for (int A = 0; A < vars.size(); ++A) {
            for (int B = 0; B < vars.size(); ++B) {
                if (BitOps::set_intersection(A, B) != 0) continue; // A and B must be disjoint
                for (int C = 0; C < vars.size(); ++C) {
                    for (int D = 0; D < vars.size(); ++D) {
                        if (BitOps::set_intersection(C, D) != 0) continue; // C and D must be disjoint
                        int AB = BitOps::set_union(A, B);
                        int CD = BitOps::set_union(C, D);
                        // ((R[A][C] ∧ ¬R[C][A]) ∧ (R[B][D] ∧ ¬R[D][B])) → (R[AB][CD] ∧ ¬R[CD][AB])
                        z3::expr A_less_C = vars.get_R(A, C) && !vars.get_R(C, A);
                        z3::expr B_less_D = vars.get_R(B, D) && !vars.get_R(D, B);
                        z3::expr AB_less_CD = vars.get_R(AB, CD) && !vars.get_R(CD, AB);
                        s.add(z3::implies(A_less_C && B_less_D, AB_less_CD));
                    }
                }
            }
        }
    }

    // Encode all common (partition-independent) axioms at once
    void encode_common_axioms(z3::solver& s) {
        encode_transitivity(s);
        encode_monotonicity(s);
        encode_non_triviality(s);
        encode_CSTP(s);
        encode_strict_CSTP(s);
    }

    // Axiom: Not Dilation (Not DLT) - Dilation does not hold for the relation R with respect to a given partition of the universe Omega where dilation means that there is a pair of subsets E and F such that for every element C in the partition, E and F are R-comparable but (E∩C) and (F∩C) are not. Thus, Not Dilation: ∀E,F: comparable(E,F) → ∃C∈partition: comparable(E∩C, F∩C) where comparable(X,Y) means R[X][Y] ∨ R[Y][X].
    void encode_not_dilation(z3::solver& s, const std::vector<int>& partition) {
        if (!silent) std::cout << "  Encoding Not Dilation (Not DLT)...\n";
        
        // Verify partition before encoding (silent verification)
        int full_set = (1 << vars.universe_size()) - 1;
        int union_all = 0;
        for (int cell : partition) {
            if (cell == 0) return;  // Invalid partition
            union_all |= cell;
        }
        if (union_all != full_set) return;  // Invalid partition

        for (int E = 0; E < vars.size(); ++E) {
            for (int F = 0; F < vars.size(); ++F) {
                // Build disjunction: ∃C∈partition such that (E∩C, F∩C) are comparable
                z3::expr_vector disjuncts(vars.context());
                for (int C : partition) {
                    int EC = BitOps::set_intersection(E, C);
                    int FC = BitOps::set_intersection(F, C);
                    // (E∩C) and (F∩C) are R-comparable
                    disjuncts.push_back(vars.get_R(EC, FC) || vars.get_R(FC, EC));
                }
                
                z3::expr E_F_comparable = vars.get_R(E, F) || vars.get_R(F, E);
                z3::expr exists_C_comparable = z3::mk_or(disjuncts);
                
                // comparable(E,F) → ∃C∈partition: comparable(E∩C, F∩C)
                s.add(z3::implies(E_F_comparable, exists_C_comparable));
            }
        }
    }

    // Axiom: Agreeing to Disagree (A2D) - There exists a pair of subsets E and F such that 
    // CK[E∩I1 ≤ F∩I1] ∩ CK[E∩I2 ≰ F∩I2] ≠ ∅
    // where [E∩I1 ≤ F∩I1] = ∪{C ∈ I1 | R[E∩C][F∩C]} 
    // and [E∩I2 ≰ F∩I2] = ∪{C ∈ I2 | ¬R[E∩C][F∩C]}
    // CK[S] = largest element in (F1 ∩ F2) that is contained in S
    void encode_A2D(z3::solver& s, const std::vector<int>& I1, const std::vector<int>& I2) {
        if (!silent) std::cout << "  Encoding Agreeing to Disagree (A2D)...\n";
        
        int n = vars.universe_size();
        
        // Verify partitions (silent)
        int full_set = (1 << n) - 1;
        auto check_partition = [full_set](const std::vector<int>& p) {
            int u = 0;
            for (int c : p) { if (c == 0) return false; u |= c; }
            return u == full_set;
        };
        if (!check_partition(I1) || !check_partition(I2)) return;
        
        // ============================================
        // PHASE 1: Static Precomputation
        // ============================================
        
        // 1.1 Generate fields
        std::vector<int> F1 = BitOps::generate_field(I1, n);
        std::vector<int> F2 = BitOps::generate_field(I2, n);
        
        // 1.2 Compute common field (set intersection of F1 and F2)
        std::vector<int> common_field;
        for (int g : F1) {
            for (int h : F2) {
                if (g == h) {
                    common_field.push_back(g);
                    break;
                }
            }
        }
        // Sort by cardinality descending for efficient CK computation
        std::sort(common_field.begin(), common_field.end(), 
            [](int a, int b) { return BitOps::cardinality(a) > BitOps::cardinality(b); });
        
        // 1.3 Compute CK[S] for all S in F1 ∪ F2
        // CK[S] = largest element in common_field that is subset of S
        auto compute_CK = [&common_field](int S) -> int {
            for (int G : common_field) {  // Already sorted by cardinality descending
                if (BitOps::is_subset(G, S)) {
                    return G;
                }
            }
            return 0;  // Empty set is always in common_field
        };
        
        // 1.4 Build lookup table T = {(A, B) | A ∈ F1, B ∈ F2, CK[A] ∩ CK[B] ≠ ∅}
        std::vector<std::pair<int, int>> T;
        for (int A : F1) {
            for (int B : F2) {
                int CK_A = compute_CK(A);
                int CK_B = compute_CK(B);
                if (BitOps::set_intersection(CK_A, CK_B) != 0) {
                    T.push_back({A, B});
                }
            }
        }
        
        if (!silent) {
            std::cout << "    Fields: |F1|=" << F1.size() << ", |F2|=" << F2.size() 
                      << ", |common|=" << common_field.size() << ", |T|=" << T.size() << "\n";
        }
        
        // 1.5 For each A ∈ F1, find which cells compose it
        // cells_in1[A] = {C ∈ I1 | C ⊆ A}
        std::map<int, std::vector<int>> cells_in1;
        for (int A : F1) {
            for (int C : I1) {
                if (BitOps::is_subset(C, A)) {
                    cells_in1[A].push_back(C);
                }
            }
        }
        
        // 1.6 For each B ∈ F2, find which cells compose it
        std::map<int, std::vector<int>> cells_in2;
        for (int B : F2) {
            for (int C : I2) {
                if (BitOps::is_subset(C, B)) {
                    cells_in2[B].push_back(C);
                }
            }
        }
        
        // Helper to check if cell C is in the list
        auto cell_in_list = [](int C, const std::vector<int>& list) -> bool {
            return std::find(list.begin(), list.end(), C) != list.end();
        };
        
        // ============================================
        // PHASE 2: Build Symbolic Constraint
        // ============================================
        
        z3::expr_vector big_disjuncts(vars.context());
        
        for (int E = 0; E < vars.size(); ++E) {
            for (int F = 0; F < vars.size(); ++F) {
                for (const auto& [A, B] : T) {
                    z3::expr_vector conjuncts(vars.context());
                    
                    // Constraint: A = [E∩I1 ≤ F∩I1]
                    // For each C ∈ I1: C ⊆ A ⟺ R[E∩C][F∩C]
                    for (int C : I1) {
                        int EC = BitOps::set_intersection(E, C);
                        int FC = BitOps::set_intersection(F, C);
                        
                        if (cell_in_list(C, cells_in1[A])) {
                            // C ⊆ A ⟹ must have E∩C ≤ F∩C
                            conjuncts.push_back(vars.get_R(EC, FC));
                        } else {
                            // C ⊄ A ⟹ must have E∩C ≰ F∩C
                            conjuncts.push_back(!vars.get_R(EC, FC));
                        }
                    }
                    
                    // Constraint: B = [E∩I2 ≰ F∩I2]
                    // For each C ∈ I2: C ⊆ B ⟺ ¬R[E∩C][F∩C]
                    for (int C : I2) {
                        int EC = BitOps::set_intersection(E, C);
                        int FC = BitOps::set_intersection(F, C);
                        
                        if (cell_in_list(C, cells_in2[B])) {
                            // C ⊆ B ⟹ must have E∩C ≰ F∩C
                            conjuncts.push_back(!vars.get_R(EC, FC));
                        } else {
                            // C ⊄ B ⟹ must have E∩C ≤ F∩C
                            conjuncts.push_back(vars.get_R(EC, FC));
                        }
                    }
                    
                    // This (E, F, A, B) tuple contributes to the disjunction
                    if (conjuncts.size() > 0) {
                        big_disjuncts.push_back(z3::mk_and(conjuncts));
                    }
                }
            }
        }
        
        // ============================================
        // PHASE 3: Add to Solver
        // ============================================
        
        if (big_disjuncts.size() > 0) {
            s.add(z3::mk_or(big_disjuncts));
            if (!silent) {
                std::cout << "    Added A2D constraint with " << big_disjuncts.size() << " disjuncts\n";
            }
        } else {
            if (!silent) {
                std::cout << "    Warning: No A2D disjuncts generated (T is empty)\n";
            }
        }
    }
};

// ============================================================
//  Task - Represents a single search task (partition pair)
// ============================================================

struct Task {
    int id;
    std::vector<int> partition1;  // I1
    std::vector<int> partition2;  // I2
};

// ============================================================
//  TaskQueue - Thread-safe work queue
// ============================================================

class TaskQueue {
    std::queue<Task> tasks;
    std::mutex mtx;
    std::condition_variable cv;
    bool finished = false;

public:
    void push(Task t) {
        std::lock_guard<std::mutex> lock(mtx);
        tasks.push(std::move(t));
        cv.notify_one();
    }
    
    bool try_pop(Task& t) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [this]() { return !tasks.empty() || finished; });
        if (tasks.empty()) return false;
        t = std::move(tasks.front());
        tasks.pop();
        return true;
    }
    
    void mark_finished() {
        std::lock_guard<std::mutex> lock(mtx);
        finished = true;
        cv.notify_all();
    }
    
    size_t size() {
        std::lock_guard<std::mutex> lock(mtx);
        return tasks.size();
    }
};

// ============================================================
//  GlobalStopFlag - Coordinates early termination
// ============================================================

class GlobalStopFlag {
    std::atomic<bool> found{false};
    std::atomic<int> winning_task_id{-1};
    std::mutex result_mutex;
    
    // Store winning result (extracted matrix, not z3::model which is context-dependent)
    std::vector<std::vector<bool>> winning_matrix;
    Task winning_task;
    int universe_size_stored = 0;

public:
    bool should_stop() const { return found.load(); }
    
    void report_solution(int task_id, const Task& task, 
                         const std::vector<std::vector<bool>>& matrix,
                         int universe_size) {
        std::lock_guard<std::mutex> lock(result_mutex);
        if (!found.load()) {
            found.store(true);
            winning_task_id.store(task_id);
            winning_task = task;
            winning_matrix = matrix;
            universe_size_stored = universe_size;
        }
    }
    
    bool has_solution() const { return found.load(); }
    int get_winning_task_id() const { return winning_task_id.load(); }
    
    Task get_winning_task() {
        std::lock_guard<std::mutex> lock(result_mutex);
        return winning_task;
    }
    
    std::vector<std::vector<bool>> get_winning_matrix() {
        std::lock_guard<std::mutex> lock(result_mutex);
        return winning_matrix;
    }
    
    int get_universe_size() {
        std::lock_guard<std::mutex> lock(result_mutex);
        return universe_size_stored;
    }
};

// ============================================================
//  SolverWorker - Worker thread that processes tasks
// ============================================================

class SolverWorker {
    int worker_id;
    int universe_size;
    TaskQueue& queue;
    GlobalStopFlag& stop_flag;
    std::atomic<int>& tasks_completed;
    std::mutex& io_mutex;
    
    // 1 hour timeout per task - drop and move on if exceeded
    static constexpr unsigned int SOLVER_TIMEOUT_MS = 3600000;

public:
    SolverWorker(int id, int n, TaskQueue& q, GlobalStopFlag& sf, 
                 std::atomic<int>& tc, std::mutex& iom)
        : worker_id(id), universe_size(n), queue(q), stop_flag(sf),
          tasks_completed(tc), io_mutex(iom) {}
    
    void run() {
        // Create thread-local Z3 context and variables
        z3::context local_ctx;
        FrameVariables local_vars(local_ctx, universe_size, /*silent=*/true);
        AxiomEncoder encoder(local_vars, /*silent=*/true);
        
        Task task;
        while (!stop_flag.should_stop() && queue.try_pop(task)) {
            // Create fresh solver for this task
            z3::solver solver(local_ctx);
            
            // Set timeout - drop and move on after this time
            z3::params p(local_ctx);
            p.set("timeout", SOLVER_TIMEOUT_MS);
            solver.set(p);
            
            // Encode common axioms
            encoder.encode_common_axioms(solver);
            
            // Encode partition-specific axioms
            encoder.encode_not_dilation(solver, task.partition1);
            encoder.encode_not_dilation(solver, task.partition2);
            encoder.encode_A2D(solver, task.partition1, task.partition2);
            
            // Solve (single attempt with long timeout)
            z3::check_result result = solver.check();
            
            // Check for early termination by another worker
            if (stop_flag.should_stop()) {
                return;
            }
            
            if (result == z3::sat) {
                // Extract matrix before reporting (model is context-dependent)
                z3::model m = solver.get_model();
                int ps = local_vars.size();
                std::vector<std::vector<bool>> matrix(ps, std::vector<bool>(ps));
                for (int i = 0; i < ps; ++i) {
                    for (int j = 0; j < ps; ++j) {
                        matrix[i][j] = m.eval(local_vars.get_R(i, j)).is_true();
                    }
                }
                
                stop_flag.report_solution(task.id, task, matrix, universe_size);
                
                {
                    std::lock_guard<std::mutex> lock(io_mutex);
                    std::cout << "[Worker " << worker_id << "] FOUND SOLUTION for task " 
                              << task.id << "!\n";
                }
                return;
            }
            
            // Task completed (UNSAT or TIMEOUT) - move on to next task
            int completed = ++tasks_completed;
            if (!stop_flag.should_stop()) {
                std::lock_guard<std::mutex> lock(io_mutex);
                std::cout << "[Worker " << worker_id << "] Task " << task.id 
                          << " completed (" << (result == z3::unsat ? "UNSAT" : "TIMEOUT")
                          << "). Progress: " << completed << " tasks done.\n";
            }
        }
    }
};

// ============================================================
//  ParallelFrameFinder - Orchestrates parallel search
// ============================================================

class ParallelFrameFinder {
    int universe_size;
    int num_threads;
    TaskQueue queue;
    GlobalStopFlag stop_flag;
    std::vector<std::thread> workers;
    std::atomic<int> tasks_completed{0};
    std::mutex io_mutex;

public:
    ParallelFrameFinder(int n, int threads = 0)
        : universe_size(n), 
          num_threads(threads > 0 ? threads : std::thread::hardware_concurrency()) {
        if (num_threads == 0) num_threads = 4;  // Fallback
    }
    
    // Main entry point: find a frame satisfying all axioms for some partition pair
    bool find_frame() {
        auto start_time = std::chrono::steady_clock::now();
        
        // Generate all partition pairs
        std::cout << "Generating partition pairs for universe size " << universe_size << "...\n";
        auto pairs = PartitionEnumerator::generate_partition_pairs(universe_size);
        std::cout << "Generated " << pairs.size() << " partition pairs\n";
        std::cout << "Using " << num_threads << " worker threads\n\n";
        
        // Populate task queue
        for (size_t i = 0; i < pairs.size(); ++i) {
            queue.push(Task{static_cast<int>(i), pairs[i].first, pairs[i].second});
        }
        queue.mark_finished();
        
        // Launch workers
        for (int i = 0; i < num_threads; ++i) {
            workers.emplace_back([this, i]() {
                SolverWorker worker(i, universe_size, queue, stop_flag, 
                                    tasks_completed, io_mutex);
                worker.run();
            });
        }
        
        // Wait for all workers
        for (auto& t : workers) {
            t.join();
        }
        
        auto end_time = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        
        std::cout << "\n=== SEARCH COMPLETE ===\n";
        std::cout << "Total time: " << duration.count() << " ms\n";
        std::cout << "Tasks completed: " << tasks_completed.load() << "/" << pairs.size() << "\n";
        
        return stop_flag.has_solution();
    }
    
    // Display results after find_frame() returns true
    void display_result() {
        if (!stop_flag.has_solution()) {
            std::cout << "No solution found.\n";
            return;
        }
        
        Task task = stop_flag.get_winning_task();
        auto matrix = stop_flag.get_winning_matrix();
        int n = stop_flag.get_universe_size();
        int ps = static_cast<int>(matrix.size());
        
        std::cout << "\n=== WINNING SOLUTION ===\n";
        std::cout << "Task ID: " << task.id << "\n";
        std::cout << "Partition I1: " << BitOps::partition_to_string(task.partition1, n) << "\n";
        std::cout << "Partition I2: " << BitOps::partition_to_string(task.partition2, n) << "\n";
        
        // Compute minimal monotonic relation (i ⊆ j)
        std::vector<std::vector<bool>> minimal(ps, std::vector<bool>(ps, false));
        for (int i = 0; i < ps; ++i) {
            for (int j = 0; j < ps; ++j) {
                minimal[i][j] = BitOps::is_subset(i, j);
            }
        }
        
        // Count extensions beyond minimal
        int extension_count = 0;
        for (int i = 0; i < ps; ++i) {
            for (int j = 0; j < ps; ++j) {
                if (matrix[i][j] && !minimal[i][j]) {
                    extension_count++;
                }
            }
        }
        
        // Display matrix with highlighting
        std::cout << "\nBoolean Matrix R[i][j]:\n";
        std::cout << "  '1' = true (required by monotonicity: i ⊆ j)\n";
        std::cout << "  '+' = true (EXTENSION beyond minimal monotonic relation)\n";
        std::cout << "  '.' = false\n\n";
        
        int col_width = (ps > 10) ? 3 : 2;
        
        // Header row
        std::cout << "     ";
        for (int j = 0; j < ps; ++j) {
            std::cout << std::setw(col_width) << j;
        }
        std::cout << "\n     ";
        for (int j = 0; j < ps; ++j) {
            for (int w = 0; w < col_width; ++w) std::cout << "-";
        }
        std::cout << "\n";
        
        // Data rows with highlighting
        for (int i = 0; i < ps; ++i) {
            std::cout << std::setw(3) << i << " | ";
            for (int j = 0; j < ps; ++j) {
                char symbol;
                if (matrix[i][j]) {
                    // True entry: check if it's required by monotonicity or an extension
                    symbol = minimal[i][j] ? '1' : '+';
                } else {
                    // False entry: check if this violates monotonicity (should not happen)
                    symbol = minimal[i][j] ? '!' : '.';
                }
                std::cout << std::setw(col_width) << symbol;
            }
            std::cout << " | " << BitOps::to_string(i, n) << "\n";
        }
        
        // Summary of extensions
        std::cout << "\nExtensions beyond minimal monotonic relation: " 
                  << extension_count << " entries (marked with '+')\n";
        
        // Verify solution
        verify_solution(matrix, task, n);
        
        // Natural language description (decoupled analysis)
        ModelAnalyzer::describe_model(matrix, n);
    }

private:
    void verify_solution(const std::vector<std::vector<bool>>& matrix, 
                         const Task& task, int n) {
        int ps = static_cast<int>(matrix.size());
        std::cout << "\n=== VERIFICATION ===\n";
        
        // Check reflexivity (implied by monotonicity: i ⊆ i)
        bool reflexive_ok = true;
        for (int i = 0; i < ps; ++i) {
            if (!matrix[i][i]) { reflexive_ok = false; break; }
        }
        std::cout << "Reflexivity: " << (reflexive_ok ? "PASS" : "FAIL") << "\n";
        
        // Check transitivity
        bool transitive_ok = true;
        for (int i = 0; i < ps && transitive_ok; ++i) {
            for (int j = 0; j < ps && transitive_ok; ++j) {
                for (int k = 0; k < ps && transitive_ok; ++k) {
                    if (matrix[i][j] && matrix[j][k] && !matrix[i][k]) {
                        transitive_ok = false;
                    }
                }
            }
        }
        std::cout << "Transitivity: " << (transitive_ok ? "PASS" : "FAIL") << "\n";
        
        // Check monotonicity
        bool monotonicity_ok = true;
        for (int i = 0; i < ps; ++i) {
            for (int j = 0; j < ps; ++j) {
                if (BitOps::is_subset(i, j) && !matrix[i][j]) {
                    monotonicity_ok = false;
                }
            }
        }
        std::cout << "Monotonicity: " << (monotonicity_ok ? "PASS" : "FAIL") << "\n";
        
        // Check non-triviality
        int full_set = ps - 1;
        bool non_triviality_ok = !matrix[full_set][0];
        std::cout << "Non-triviality: " << (non_triviality_ok ? "PASS" : "FAIL") << "\n";
        
        // Check CSTP
        bool cstp_ok = true;
        for (int A = 0; A < ps && cstp_ok; ++A) {
            for (int B = 0; B < ps && cstp_ok; ++B) {
                if (BitOps::set_intersection(A, B) != 0) continue;
                for (int C = 0; C < ps && cstp_ok; ++C) {
                    for (int D = 0; D < ps && cstp_ok; ++D) {
                        if (BitOps::set_intersection(C, D) != 0) continue;
                        int AB = BitOps::set_union(A, B);
                        int CD = BitOps::set_union(C, D);
                        if (matrix[A][C] && matrix[B][D] && !matrix[AB][CD]) {
                            cstp_ok = false;
                        }
                    }
                }
            }
        }
        std::cout << "CSTP: " << (cstp_ok ? "PASS" : "FAIL") << "\n";
        
        // Check Strict CSTP
        bool strict_cstp_ok = true;
        for (int A = 0; A < ps && strict_cstp_ok; ++A) {
            for (int B = 0; B < ps && strict_cstp_ok; ++B) {
                if (BitOps::set_intersection(A, B) != 0) continue;
                for (int C = 0; C < ps && strict_cstp_ok; ++C) {
                    for (int D = 0; D < ps && strict_cstp_ok; ++D) {
                        if (BitOps::set_intersection(C, D) != 0) continue;
                        int AB = BitOps::set_union(A, B);
                        int CD = BitOps::set_union(C, D);
                        bool A_less_C = matrix[A][C] && !matrix[C][A];
                        bool B_less_D = matrix[B][D] && !matrix[D][B];
                        bool AB_less_CD = matrix[AB][CD] && !matrix[CD][AB];
                        if (A_less_C && B_less_D && !AB_less_CD) {
                            strict_cstp_ok = false;
                        }
                    }
                }
            }
        }
        std::cout << "Strict CSTP: " << (strict_cstp_ok ? "PASS" : "FAIL") << "\n";
        
        // Check Not Dilation for I1 and I2
        auto check_not_dilation = [&](const std::vector<int>& partition, const std::string& name) {
            bool ok = true;
            for (int E = 0; E < ps && ok; ++E) {
                for (int F = 0; F < ps && ok; ++F) {
                    bool EF_comparable = matrix[E][F] || matrix[F][E];
                    if (!EF_comparable) continue;
                    
                    bool exists_comparable = false;
                    for (int C : partition) {
                        int EC = BitOps::set_intersection(E, C);
                        int FC = BitOps::set_intersection(F, C);
                        if (matrix[EC][FC] || matrix[FC][EC]) {
                            exists_comparable = true;
                            break;
                        }
                    }
                    if (!exists_comparable) ok = false;
                }
            }
            std::cout << "Not Dilation (" << name << "): " << (ok ? "PASS" : "FAIL") << "\n";
        };
        
        check_not_dilation(task.partition1, "I1");
        check_not_dilation(task.partition2, "I2");
    }
};

// ============================================================
//  FrameFinder - Solver orchestrator (single-threaded version)
// ============================================================
//  Owns context, solver, variables, and encoder
// ============================================================

class FrameFinder {
    z3::context ctx;
    z3::solver s;
    FrameVariables vars;
    AxiomEncoder enc;

public:
    FrameFinder(int universe_size)
        : ctx(), s(ctx), vars(ctx, universe_size), enc(vars) {
        std::cout << "FrameFinder initialized for universe size " << universe_size << "\n";
        std::cout << "Powerset has " << vars.size() << " subsets\n";
    }

    // Accessors
    z3::solver& solver() { return s; }
    AxiomEncoder& encoder() { return enc; }
    FrameVariables& variables() { return vars; }

    // Solve and return result
    z3::check_result solve() {
        std::cout << "\nSearching for solution...\n";
        return s.check();
    }

    // Get model (call after SAT)
    z3::model get_model() {
        return s.get_model();
    }

    // Display model
    void display_model() {
        z3::model m = get_model();
        int ps = vars.size();
        int n = vars.universe_size();

        std::cout << "\n=== FRAME FOUND ===\n\n";

        // Extract boolean matrix
        std::vector<std::vector<bool>> matrix(ps, std::vector<bool>(ps));
        for (int i = 0; i < ps; ++i) {
            for (int j = 0; j < ps; ++j) {
                matrix[i][j] = m.eval(vars.get_R(i, j)).is_true();
            }
        }

        // Display matrix
        std::cout << "Boolean Matrix R[i][j] (1 means subset_i <= subset_j):\n\n";
        
        // Determine column width based on max index
        int col_width = (ps > 10) ? 3 : 2;
        
        // Header row with column indices
        std::cout << "     ";
        for (int j = 0; j < ps; ++j) {
            std::cout << std::setw(col_width) << j;
        }
        std::cout << "\n     ";
        for (int j = 0; j < ps; ++j) {
            for (int w = 0; w < col_width; ++w) std::cout << "-";
        }
        std::cout << "\n";

        // Data rows
        for (int i = 0; i < ps; ++i) {
            std::cout << std::setw(3) << i << " | ";
            for (int j = 0; j < ps; ++j) {
                std::cout << std::setw(col_width) << (matrix[i][j] ? "1" : ".");
            }
            std::cout << " | " << BitOps::to_string(i, n) << "\n";
        }

        // Verify properties for tests
        verify_preorder(matrix);
        verify_monotonicity(matrix);
        verify_non_triviality(matrix);
        verify_CSTP(matrix);
        verify_strict_CSTP(matrix);
    }

private:
    void verify_preorder(const std::vector<std::vector<bool>>& matrix) {
        int ps = vars.size();
        std::cout << "\n=== VERIFICATION ===\n";

        // Check reflexivity
        bool reflexive_ok = true;
        for (int i = 0; i < ps; ++i) {
            if (!matrix[i][i]) {
                reflexive_ok = false;
                break;
            }
        }
        std::cout << "Reflexivity: " << (reflexive_ok ? "PASS" : "FAIL") << "\n";
        assert(reflexive_ok && "Reflexivity check failed");

        // Check transitivity
        bool transitive_ok = true;
        for (int i = 0; i < ps && transitive_ok; ++i) {
            for (int j = 0; j < ps && transitive_ok; ++j) {
                for (int k = 0; k < ps && transitive_ok; ++k) {
                    if (matrix[i][j] && matrix[j][k] && !matrix[i][k]) {
                        transitive_ok = false;
                    }
                }
            }
        }
        std::cout << "Transitivity: " << (transitive_ok ? "PASS" : "FAIL") << "\n";
        assert(transitive_ok && "Transitivity check failed");
    }

    void verify_monotonicity(const std::vector<std::vector<bool>>& matrix) {
        int ps = vars.size();
        int n = vars.universe_size();
        bool monotonicity_ok = true;

        for (int i = 0; i < ps; ++i) {
            for (int j = 0; j < ps; ++j) {
                if (BitOps::is_subset(i, j) && !matrix[i][j]) {
                    monotonicity_ok = false;
                    std::cout << "Monotonicity violation: " 
                              << BitOps::to_string(i, n) << " ⊆ " 
                              << BitOps::to_string(j, n) 
                              << " but not " << i << " <= " << j << "\n";
                }
            }
        }
        std::cout << "Monotonicity: " << (monotonicity_ok ? "PASS" : "FAIL") << "\n";
        assert(monotonicity_ok && "Monotonicity check failed");
    }

    void verify_non_triviality(const std::vector<std::vector<bool>>& matrix) {
        int full_set = vars.size() - 1;
        int empty_set = 0;
        bool non_triviality_ok = !matrix[full_set][empty_set];

        std::cout << "Non-triviality: " << (non_triviality_ok ? "PASS" : "FAIL") << "\n";
        assert(non_triviality_ok && "Non-triviality check failed");
    }

    void verify_CSTP(const std::vector<std::vector<bool>>& matrix) {
        int ps = vars.size();
        bool cstp_ok = true;

        for (int A = 0; A < ps; ++A) {
            for (int B = 0; B < ps; ++B) {
                if (BitOps::set_intersection(A, B) != 0) continue; // A and B must be disjoint
                for (int C = 0; C < ps; ++C) {
                    for (int D = 0; D < ps; ++D) {
                        if (BitOps::set_intersection(C, D) != 0) continue; // C and D must be disjoint
                        int AB = BitOps::set_union(A, B);
                        int CD = BitOps::set_union(C, D);
                        if (matrix[A][C] && matrix[B][D] && !matrix[AB][CD]) {
                            cstp_ok = false;
                            std::cout << "CSTP violation: "
                                      << BitOps::to_string(A, vars.universe_size()) << " <= "
                                      << BitOps::to_string(C, vars.universe_size()) << " and "
                                      << BitOps::to_string(B, vars.universe_size()) << " ≤ "
                                      << BitOps::to_string(D, vars.universe_size())
                                      << " but not " << BitOps::to_string(AB, vars.universe_size())
                                      << " ≤ " << BitOps::to_string(CD, vars.universe_size()) << "\n";
                        }
                    }
                }
            }
        }
        std::cout << "CSTP: " << (cstp_ok ? "PASS" : "FAIL") << "\n";
        assert(cstp_ok && "CSTP check failed");
    }

    void verify_strict_CSTP(const std::vector<std::vector<bool>>& matrix) {
        int ps = vars.size();
        bool strict_cstp_ok = true;

        for (int A = 0; A < ps; ++A) {
            for (int B = 0; B < ps; ++B) {
                if (BitOps::set_intersection(A, B) != 0) continue; // A and B must be disjoint
                for (int C = 0; C < ps; ++C) {
                    for (int D = 0; D < ps; ++D) {
                        if (BitOps::set_intersection(C, D) != 0) continue; // C and D must be disjoint
                        int AB = BitOps::set_union(A, B);
                        int CD = BitOps::set_union(C, D);
                        bool A_less_C = matrix[A][C] && !matrix[C][A];
                        bool B_less_D = matrix[B][D] && !matrix[D][B];
                        bool AB_less_CD = matrix[AB][CD] && !matrix[CD][AB];
                        if (A_less_C && B_less_D && !AB_less_CD) {
                            strict_cstp_ok = false;
                            std::cout << "Strict CSTP violation: "
                                      << BitOps::to_string(A, vars.universe_size()) << " < "
                                      << BitOps::to_string(C, vars.universe_size()) << " and "
                                      << BitOps::to_string(B, vars.universe_size()) << " < "
                                      << BitOps::to_string(D, vars.universe_size())
                                      << " but not " << BitOps::to_string(AB, vars.universe_size())
                                      << " < " << BitOps::to_string(CD, vars.universe_size()) << "\n";
                        }
                    }
                }
            }
        }
        std::cout << "Strict CSTP: " << (strict_cstp_ok ? "PASS" : "FAIL") << "\n";
        assert(strict_cstp_ok && "Strict CSTP check failed");
    }
};

// ============================================================
//  WitnessExtractor - Standalone functions for witness extraction
// ============================================================
//  Decoupled from FrameFinder; call only when needed
// ============================================================

namespace WitnessExtractor {
    
    // Extract and display witnesses for Dilation
    // Dilation witness: (E, F, C) where E and F are comparable but (E∩C) and (F∩C) are incomparable
    void extract_dilation_witnesses(
        const z3::model& model,
        const FrameVariables& vars,
        const std::vector<int>& partition
    ) {
        int ps = vars.size();
        int n = vars.universe_size();
        
        std::cout << "\n=== DILATION WITNESSES ===\n";
        std::cout << "For comparable pairs (E, F), showing cells C where (E∩C, F∩C) are INCOMPARABLE\n\n";
        
        int witness_count = 0;
        
        for (int E = 0; E < ps; ++E) {
            for (int F = E + 1; F < ps; ++F) {  // Only check E < F to avoid duplicates
                // Check if E and F are comparable
                bool E_leq_F = model.eval(vars.get_R(E, F)).is_true();
                bool F_leq_E = model.eval(vars.get_R(F, E)).is_true();
                bool E_F_comparable = E_leq_F || F_leq_E;
                
                if (!E_F_comparable) continue;
                
                // Find cells C where (E∩C, F∩C) are incomparable
                for (int C : partition) {
                    int EC = BitOps::set_intersection(E, C);
                    int FC = BitOps::set_intersection(F, C);
                    
                    bool EC_leq_FC = model.eval(vars.get_R(EC, FC)).is_true();
                    bool FC_leq_EC = model.eval(vars.get_R(FC, EC)).is_true();
                    bool EC_FC_incomparable = !EC_leq_FC && !FC_leq_EC;
                    
                    if (EC_FC_incomparable) {
                        std::cout << "E=" << BitOps::to_string(E, n) 
                                  << ", F=" << BitOps::to_string(F, n)
                                  << " (comparable: " << (E_leq_F ? "E≤F" : "") << (F_leq_E ? "F≤E" : "") << ")"
                                  << "\n  Cell C=" << BitOps::to_string(C, n)
                                  << " → E∩C=" << BitOps::to_string(EC, n)
                                  << ", F∩C=" << BitOps::to_string(FC, n)
                                  << " (INCOMPARABLE)"
                                  << "\n";
                        witness_count++;
                    }
                }
            }
        }
        
        std::cout << "\nTotal dilation witnesses (E, F, C): " << witness_count << "\n";
        if (witness_count == 0) {
            std::cout << "No dilation witnesses found - Not Dilation axiom is satisfied.\n";
        }
    }
}

// ============================================================
//  Main - Parallel Frame Finding for Universe Size 4
// ============================================================
//  Searches all 15*14 = 210 partition pairs using multiple threads
// ============================================================

int main(int argc, char* argv[]) {
    // Configuration
    int universe_size = 4;  // {0, 1, 2, 3}
    int num_threads = 8;    // Default to 8 threads
    
    // Parse command line arguments
    if (argc >= 2) {
        universe_size = std::atoi(argv[1]);
        if (universe_size < 2 || universe_size > 6) {
            std::cerr << "Universe size must be between 2 and 6. Using default (4).\n";
            universe_size = 4;
        }
    }
    if (argc >= 3) {
        num_threads = std::atoi(argv[2]);
        if (num_threads < 1) {
            num_threads = std::thread::hardware_concurrency();
            if (num_threads == 0) num_threads = 4;
        }
    }
    
    std::cout << "===========================================\n";
    std::cout << "   Parallel Finite Frame Finder (Z3)\n";
    std::cout << "===========================================\n\n";
    std::cout << "Universe size: " << universe_size << " (Omega = {0.." << (universe_size-1) << "})\n";
    std::cout << "Powerset size: " << (1 << universe_size) << " subsets\n";
    std::cout << "Threads: " << num_threads << "\n\n";
    
    // Calculate expected partition count (Bell number)
    auto all_partitions = PartitionEnumerator::generate_all_partitions(universe_size);
    int num_partitions = static_cast<int>(all_partitions.size());
    int num_pairs = num_partitions * (num_partitions - 1);
    
    std::cout << "Number of partitions (Bell(" << universe_size << ")): " << num_partitions << "\n";
    std::cout << "Number of partition pairs to search: " << num_pairs << "\n\n";
    
    // Run parallel search
    ParallelFrameFinder finder(universe_size, num_threads);
    
    bool found = finder.find_frame();
    
    if (found) {
        finder.display_result();
        std::cout << "\n=== SUCCESS ===\n";
    } else {
        std::cout << "\n=== NO SOLUTION FOUND ===\n";
        std::cout << "Searched all " << num_pairs << " partition pairs - no frame exists.\n";
    }
    
    return found ? 0 : 1;
}

